
/*
list *eval_define(list *exp, list **env) {
  list *var = definition_variable(exp);
  list *dfn_val = definition_value(exp);
  list *val = eval(dfn_val, env);
  if(val != dfn_val)
    free(dfn_val);

  list *new_env = define_variable(getSymbol(var), val, *env);
  free(var);
  if(new_env != NULL) {
    /* mutate the env */
    *env = new_env;

    list *ret = malloc(sizeof(list));
    init_list(ret, NULL, Symbol,intern("ok", hashtable));
    return ret;
  } else {
    return NULL;
  }
}

list *eval_assignment(list *exp, list **env) {
  list *var = definition_variable(exp);
  list *val = eval(definition_value(exp), env);

  *env = set_variable(getSymbol(var), val, *env);
  free(var);

  list *ret = malloc(sizeof(list));
  init_list(ret, NULL, Symbol, intern("ok", hashtable));
  return ret;
}

list *eval_appl(list *exp, list **env) {
  /* eval the operator */
  list *op = operator(exp);
  list *ev_op = eval(op, env);
  free(op);

  /* eval the operands */
  list *opands = operands(exp);
  list *opands_data = getList(opands);
  free(opands);
  list *ev_opands = NULL;

  for(list *n = opands_data; n != NULL; n = n->next) {

    list *copy = shallow_node_copy(n);
    list *ev_opand = eval(copy, env);
    if(copy != ev_opand)
      free(copy);

    list *arg = malloc(sizeof(list));
    init_list(arg, NULL, List, ev_opand);    
    if(ev_opands == NULL) {
      ev_opands = arg;
    } else {
      append(arg, ev_opands);
    }
  }

  /* apply the operator to the operands */
  list *ret = apply(getProc(ev_op), ev_opands);
  simple_rfree(ev_opands);
  free(ev_op);

  return ret;
}

list *eval_if(list *exp, list **env) {
  list *pred = if_predicate(exp);
  list *consq = if_consequent(exp);
  list *alt = if_alternative(exp);
  list *ev_pred = eval(pred, env);
  if(truthy(ev_pred)) {
    return eval(consq, env);
  } else {
    return eval(alt, env);
  }
}

list *eval_sequence(list *exps, list **env) {
  list *n;
  /* for each but the last expression */
  for(n = exps; n->next != NULL; n = n->next) {
    list *copy = shallow_node_copy(n);
    eval(copy, env);
    free(copy);
  }

  list *ret = eval(n, env);
  return ret;
}

list *eval_lambda(list *exp, list **env) {
  procedure *lambda = malloc(sizeof(procedure));
  list *params = lambda_params(exp);
  list *body = lambda_body(exp);
  init_proc(lambda, params->data.listData, body->data.listData, *env, NULL);
  list *ret = malloc(sizeof(list));
  init_list(ret, NULL, Procedure, lambda);
  return ret;
}
*/
